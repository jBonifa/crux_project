package crux.ast;

import crux.ast.*;
import crux.ast.OpExpr.Operation;
import crux.ir.insts.BinaryOperator;
import crux.pt.CruxBaseVisitor;
import crux.pt.CruxParser;
import crux.ast.types.*;
import crux.ast.SymbolTable.Symbol;
import org.antlr.v4.runtime.ParserRuleContext;


import java.awt.datatransfer.SystemFlavorMap;
import java.io.PrintStream;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class will convert the parse tree generated by ANTLR to AST It follows the visitor pattern
 * where decls will be by DeclVisitor Class Stmts will be resolved by StmtVisitor Class Exprs will
 * be resolved by ExprVisitor Class
 */

public final class ParseTreeLower {
  private final DeclVisitor declVisitor = new DeclVisitor();
  private final StmtVisitor stmtVisitor = new StmtVisitor();
  private final ExprVisitor exprVisitor = new ExprVisitor();

  private final SymbolTable symTab;

  public ParseTreeLower(PrintStream err) {
    symTab = new SymbolTable(err);
  }

  private static Position makePosition(ParserRuleContext ctx) {
    var start = ctx.start;
    return new Position(start.getLine());
  }

  /**
   *
   * @return True if any errors
   */
  public boolean hasEncounteredError() {
    return symTab.hasEncounteredError();
  }


  /**
   * Lower top-level parse tree to AST
   *
   * @return a {@link DeclList} object representing the top-level AST.
   */

  public DeclarationList lower(CruxParser.ProgramContext program) {
    ArrayList<Declaration> list = new ArrayList<Declaration>();
    for (CruxParser.DeclContext context : program.declList().decl()) {
      Declaration node = context.accept(declVisitor);
      list.add(node);
    }
    return new DeclarationList(makePosition(program), list);
  }

  /**
   * Lower stmt list by lower individual stmt into AST.
   *
   * @return a {@link StmtList} AST object.
   */

  
  private StatementList lower(CruxParser.StmtListContext stmtList) {
    ArrayList<Statement> list = new ArrayList<Statement>();
    for (CruxParser.StmtContext context : stmtList.stmt()) {
      Statement node = context.accept(stmtVisitor);
      list.add(node);
    }
    return new StatementList(makePosition(stmtList), list);
  }
   

  /**
   * Similar to {@link #lower(CruxParser.StmtListContext)}, but handles symbol table as well.
   *
   * @return a {@link StmtList} AST object.
   */

  
  private StatementList lower(CruxParser.StmtBlockContext stmtBlock) {
    ArrayList<Statement>list = new ArrayList<Statement>();
    symTab.enter();
    for (CruxParser.StmtContext context : stmtBlock.stmtList().stmt()) {
      Statement node = context.accept(stmtVisitor);
      list.add(node);
    }
    symTab.exit();
    return new StatementList(makePosition(stmtBlock), list);
  }
   

  /**
   * A parse tree visitor to create AST nodes derived from {@link Declaration}
   */
  private final class DeclVisitor extends CruxBaseVisitor<Declaration> {
    /**
     * Visit a parse tree var decl and create an AST {@link VarariableDeclaration}
     *
     * @return an AST {@link VariableDeclaration}
     */

    @Override
     public VariableDeclaration visitVarDecl(CruxParser.VarDeclContext ctx) {
      String s = ctx.type().getText();
      Type t;
      if (s.equals("bool")) {
        t = new BoolType();
      } else if (s.equals("int")){
        t = new IntType();
      }
      else {t = new VoidType();}
       Symbol symbol = symTab.add(makePosition(ctx), ctx.Identifier().getText(), t);
       return new VariableDeclaration(makePosition(ctx), symbol);
     }




    /**
     * Visit a parse tree array decl and creates an AST {@link ArrayDeclaration}
     *
     * @return an AST {@link ArrayDeclaration}
     */


    @Override
     public Declaration visitArrayDecl(CruxParser.ArrayDeclContext ctx) {
      String s = ctx.type().getText();
      Type t;
      if (s.equals("bool")) {
        t = new BoolType();
      } else if (s.equals("int")){
        t = new IntType();
      }
      else {t = new VoidType();}
       ArrayType a = new ArrayType(new Integer(ctx.Integer().getText()), t);
       Symbol symbol = symTab.add(makePosition(ctx), ctx.Identifier().getText(), a);
        return new ArrayDeclaration(makePosition(ctx), symbol);
      }




    /**
     * Visit a parse tree function definition and create an AST {@link FunctionDefinition}
     *
     * @return an AST {@link FunctionDefinition}
     */


    @Override
    public Declaration visitFunctionDefn(CruxParser.FunctionDefnContext ctx) {
      //TODO FIX TYPE, USE FuncType FuncType(TypeList args, Type returnType)
      // TypeList() or ypeList(List<Type> types)
      String s = ctx.type().getText(); //this gets return type
      Type t;
      if (s.equals("bool")) {
        t = new BoolType();
      } else if (s.equals("int")){
        t = new IntType();
      }
      else {t = new VoidType();}
      ArrayList<Type> paramTypes = new ArrayList<Type>();
      Symbol symbol = symTab.add(makePosition(ctx), ctx.Identifier().getText(), new FuncType(new TypeList(paramTypes), t));
      ArrayList<Symbol> parameters = new ArrayList<Symbol>();
      ArrayList<Statement> list = new ArrayList<Statement>();
      symTab.enter();
      for (CruxParser.ParamContext context : ctx.paramList().param()) {
        String s2 = context.type().getText();
        Type t2;
        if (s2.equals("bool")) {
          t2 = new BoolType();
        } else if (s2.equals("int")){
          t2 = new IntType();
        }
        else {t2 = new VoidType();}
        paramTypes.add(t2);
        parameters.add(symTab.add(makePosition(ctx), context.Identifier().getText(), t2));
      }
      for (CruxParser.StmtContext context : ctx.stmtBlock().stmtList().stmt()) {
        Statement node = context.accept(stmtVisitor);
        list.add(node);
      }
      symTab.exit();
      return new FunctionDefinition(makePosition(ctx), symbol, parameters, new StatementList(makePosition(ctx), list));
    }

  }


  /**
   * A parse tree visitor to create AST nodes derived from {@link Stmt}
   */

  private final class StmtVisitor extends CruxBaseVisitor<Statement> {
    /**
     * Visit a parse tree var decl and create an AST {@link VariableDeclaration}. Since
     * {@link VariableDeclaration} is both {@link Declaration} and {@link Statement}, we simply
     * delegate this to {@link DeclVisitor#visitArrayDecl(CruxParser.ArrayDeclContext)} which we
     * implement earlier.
     *
     * @return an AST {@link VariableDeclaration}
     */

    @Override
    public Statement visitVarDecl(CruxParser.VarDeclContext ctx) {
      return (Statement) ctx.accept(declVisitor);
    }

    
    /**
     * Visit a parse tree assignment stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */

    @Override
    public Statement visitAssignStmt(CruxParser.AssignStmtContext ctx) {
      Expression lhs = ctx.designator().accept(exprVisitor); //designator for LHS
      Expression rhs = ctx.expr0().accept(exprVisitor);
      return new Assignment(makePosition(ctx), lhs, rhs);
    }

    
    /**
     * Visit a parse tree assignment nosemi stmt and create an AST {@link Assignment}
     *
     * @return an AST {@link Assignment}
     */
    @Override
    public Statement visitAssignStmtNoSemi(CruxParser.AssignStmtNoSemiContext ctx) {
      Expression lhs = ctx.designator().accept(exprVisitor); //designator for LHS
      Expression rhs = ctx.expr0().accept(exprVisitor);
      return new Assignment(makePosition(ctx), lhs, rhs);
    }


    /**
     * Visit a parse tree call stmt and create an AST {@link Call}. Since {@link Call} is both
     * {@link Expression} and {@link Statement}, we simply delegate this to
     * {@link ExprVisitor#visitCallExpr(CruxParser.CallExprContext)} that we will implement later.
     *
     * @return an AST {@link Call}
     */
    @Override
    public Statement visitCallStmt(CruxParser.CallStmtContext ctx) {
      return (Statement) ctx.callExpr().accept(exprVisitor);
    }
     
    
    /**
     * Visit a parse tree if-else branch and create an AST {@link IfElseBranch}. The template code
     * shows partial implementations that visit the then block and else block recursively before
     * using those returned AST nodes to construct {@link IfElseBranch} object.
     *
     * @return an AST {@link IfElseBranch}
     */
    

    @Override
    public Statement visitIfStmt(CruxParser.IfStmtContext ctx) {
      Expression e = ctx.expr0().accept(exprVisitor);
      List<Statement> l1 = new ArrayList<Statement>();
      symTab.enter();
      for (CruxParser.StmtContext context : ctx.stmtBlock(0).stmtList().stmt()) {
        Statement node = context.accept(stmtVisitor);
        l1.add(node);
      }
      symTab.exit();
      List<Statement> l2 = new ArrayList<Statement>();
      if (ctx.Else() != null) {
        symTab.enter();
        for (CruxParser.StmtContext context : ctx.stmtBlock(1).stmtList().stmt()) {
          Statement node = context.accept(stmtVisitor);
          l2.add(node);
        }
        symTab.exit();
      }
      return new IfElseBranch(makePosition(ctx), e, new StatementList(makePosition(ctx), l1),
              new StatementList(makePosition(ctx), l2));
    }


     
    
    /**
     * Visit a parse tree for loop and create an AST {@link For}. You'll going to use a similar
     * techniques as {@link #visitIfStmt(CruxParser.IfStmtContext)} to decompose this construction.
     *
     * @return an AST {@link Loop}
     */


    @Override
    public Statement visitForStmt(CruxParser.ForStmtContext ctx) {
      symTab.enter();
      Assignment init = (Assignment) ctx.assignStmt().accept(stmtVisitor);
      Expression cond = ctx.expr0().accept(exprVisitor);
      Assignment increment = (Assignment) ctx.assignStmtNoSemi().accept(stmtVisitor);
      List<Statement> list = new ArrayList<Statement>();
      for (CruxParser.StmtContext context : ctx.stmtBlock().stmtList().stmt()) {
        Statement node = context.accept(stmtVisitor);
        list.add(node);
      }
      symTab.exit();
      return new For(makePosition(ctx), init, cond, increment,
              new StatementList(makePosition(ctx), list));
    }


     

    /**
     * Visit a parse tree return stmt and create an AST {@link Return}. Here we show a simple
     * example of how to lower a simple parse tree construction.
     *
     * @return an AST {@link Return}
     */

    
    @Override
    public Statement visitReturnStmt(CruxParser.ReturnStmtContext ctx) {
      Expression e = ctx.expr0().accept(exprVisitor);
      return new Return(makePosition(ctx), e);
    }
     
    
    /**
     * Creates a Break node
     */
    
    @Override
    public Statement visitBreakStmt(CruxParser.BreakStmtContext ctx) {
      return new Break(makePosition(ctx));
    }
    
  }

  private final class ExprVisitor extends CruxBaseVisitor<Expression> {
    /**
     * Parse Expr0 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr0(CruxParser.Expr0Context ctx) {
      if (ctx.op0() != null) {
        //big case
        Expression lhs = ctx.expr1(0).accept(exprVisitor);
        Expression rhs = ctx.expr1(1).accept(exprVisitor);
        CruxParser.Op0Context op0 = ctx.op0();
        Operation op;
        if (op0.GreaterEqual() != null) {op = Operation.GE;}
        else if (op0.LesserEqual() != null) {op = Operation.LE;}
        else if (op0.NotEqual() != null) {op = Operation.NE;}
        else if (op0.Equal() != null) {op = Operation.EQ;}
        else if (op0.GreaterThan() != null) {op = Operation.GT;}
        else {op = Operation.LT;}
        return new OpExpr(makePosition(ctx), op, lhs, rhs);
      } else {
        //just exp
        return ctx.expr1(0).accept(exprVisitor);
      }
    }

    /**
     * Parse Expr1 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr1(CruxParser.Expr1Context ctx) {
      if (ctx.op1() == null) {
        //expression 2 case
        return ctx.expr2().accept(exprVisitor);
    } else {
        //expr1 op1 expr2
        Expression lhs = ctx.expr1().accept(exprVisitor);
        Expression rhs = ctx.expr2().accept(exprVisitor);
        CruxParser.Op1Context op1 = ctx.op1();
        Operation op;
        if (op1.Add() != null) {op = Operation.ADD;}
        else if (op1.Sub() != null) {op = Operation.SUB;}
        else {op = Operation.LOGIC_OR;}
        return new OpExpr(makePosition(ctx), op, lhs, rhs);
      }
    }

    /**
     * Parse Expr2 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr2(CruxParser.Expr2Context ctx) {
      if (ctx.op2() == null) {
        return ctx.expr3().accept(exprVisitor);
      } else {
        Expression lhs = ctx.expr2().accept(exprVisitor);
        Expression rhs = ctx.expr3().accept(exprVisitor);
        CruxParser.Op2Context op2 = ctx.op2();
        Operation op;
        if (op2.Mul() != null) {op = Operation.MULT;}
        else if (op2.Div() != null) {op = Operation.DIV;}
        else {op = Operation.LOGIC_AND;}
        return new OpExpr(makePosition(ctx), op, lhs, rhs);
      }

      }

    /**
     * Parse Expr3 to OpExpr Node Parsing the expr should be exactly as described in the grammer
     */
    @Override
    public Expression visitExpr3(CruxParser.Expr3Context ctx) {
      if (ctx.designator() != null) {
        return ctx.designator().accept(exprVisitor);
      } else if (ctx.literal() != null) {
        return ctx.literal().accept(exprVisitor);
      } else if (ctx.callExpr() != null) {
        return ctx.callExpr().accept(exprVisitor);
      } else if (ctx.expr0() != null) {
        return ctx.expr0().accept(exprVisitor);
      } else {
        return new OpExpr(makePosition(ctx), Operation.LOGIC_NOT, ctx.expr3().accept(exprVisitor), null);
      }
    }

    /**
     * Create an Call Node
     */
    @Override
    public Call visitCallExpr(CruxParser.CallExprContext ctx) {
      Symbol callee = symTab.lookup(makePosition(ctx), ctx.Identifier().getText());
      ArrayList<Expression> list = new ArrayList<Expression>();
      for (CruxParser.Expr0Context context : ctx.exprList().expr0()) {
        Expression node = context.accept(exprVisitor);
        list.add(node);
      }
      Statement s = new Call(makePosition(ctx), callee, list);
      return (Call) s;
    }

    /**
     * visitDesignator will check for a name or ArrayAccess FYI it should account for the case when
     * the designator was dereferenced
     */
    @Override
    public Expression visitDesignator(CruxParser.DesignatorContext ctx) {
      String name = ctx.Identifier().getText();
      Expression e;
      Symbol symbol = symTab.lookup(makePosition(ctx), name);
      if (ctx.expr0() != null) {
        e = new ArrayAccess(makePosition(ctx), symbol, ctx.expr0().accept(exprVisitor));
      } else {
        e = new VarAccess(makePosition(ctx), symbol);
      }
      return e;
    }

    /**
     * Create an Literal Node
     */
    @Override
    public Expression visitLiteral(CruxParser.LiteralContext ctx) {
      if (ctx.Integer() != null) {
        String s = ctx.getText();
        Integer i = new Integer(s);
        return new LiteralInt(makePosition(ctx), i);
      }
      else if (ctx.True() != null) {
        return new LiteralBool(makePosition(ctx),true);
      } else {
        return new LiteralBool(makePosition(ctx),false);
      }
    }
  }
}
